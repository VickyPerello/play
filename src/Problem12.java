import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Problem12 {

    static public void problem12() {
        //Highly divisible triangular number
        //Problem 12
        //The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
        //
        //1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
        //
        //Let us list the factors of the first seven triangle numbers:
        //
        // 1: 1
        // 3: 1,3
        // 6: 1,2,3,6
        //10: 1,2,5,10
        //15: 1,3,5,15
        //21: 1,3,7,21
        //28: 1,2,4,7,14,28
        //We can see that 28 is the first triangle number to have over five divisors.
        //
        //What is the value of the first triangle number to have over five hundred divisors?


        List<Integer> triangleNumbers = new ArrayList<>();
        int before = 1;
        triangleNumbers.add(before);
        boolean found = false;
        int i = 1;

        while (!found) {
            before+=1;
            int current = before + triangleNumbers.get(i-1);

            if (getDivisors(current) > 500) {
                found = true;
                System.out.print(current);
            }
            triangleNumbers.add(current);
            i++;
        }

    }

    static int getDivisors(int number) {
        int divisorsQuantity = 0;

        for (int i=1; i<=Math.sqrt(number); i++){
            if (number%i==0) {
                divisorsQuantity+=2;
            }
        }
        if (Math.sqrt(number) * Math.sqrt(number) == number) {
            divisorsQuantity--;
        }

        return divisorsQuantity;

    }

    /*
    * while (number > 1) {
            boolean hasToContinue = true;
            long divisor = 2;
            while (hasToContinue) {
                if (number%divisor == 0){
                    number = number/divisor;
                    primesFactors.add(divisor);
                    hasToContinue = false;
                } else {
                    divisor++;
                }
            }
        }*/

    /*
    * private static boolean isPrime(int number, List<Integer> primes) {
        boolean prime = true;
        int it = 0;
        while (it < primes.size() && prime) {
            if (number%primes.get(it) == 0) {
                prime = false;
            }
            it++;
        }
        return prime;

    }*/


}
